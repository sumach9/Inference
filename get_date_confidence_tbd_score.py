# -*- coding: utf-8 -*-
"""Inference_date_stat_v4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/FactFindersPro1/FFP_B2B_DS_POC/blob/main/Inference/Inference_date_stat_v4.ipynb

Data Science Team Notebook - [Inference] - [Calculate the confidence score for the fields that contain dates]
-----------------------------------------------------------
Author(s): [Anna Sviripa, Shekar Thonupunuri]
Date: [2025-04-25]
Version: 4.0

Module Description:
    This notebook is part of the Inference project and calculates confidence score for the date fields that are "MATCH_TBD"
    Final output of this notebook is the updated json file where additional fields were added, e.g. confidence_score and any components of the equation used to compute the confidence_score

    The module can be divided into the following major steps:
        1. Data Extraction and preprocessing from json
        2. Functions that calculate the metrics
        3. Final function that takes all the metrics, computes final confidence_score and updates the original json

Calculations:

1. confidence_score for date_of_degree_awarded equation:

        confidence_score = (0.375 * award_date_within_months_of_end_date) + (0.375 * award_month_expected_months)

        Where
        1. award_date_within_months_of_end_date = 1, if Award_date – end_date < 6 months
          award_date_within_months_of_end_date = 0, if Award_date – end_date > 6 month


        2.  award_month_expected_months = 1, if graduation month == May, June, December, January, February, for Bachelors, Masters, and Associates;
            award_month_expected_months = 0, if graduation month == May, June, August, December, January, February, for PhD and Doctorates;
            award_date_within_months_of_end_date = 0, otherwise

        Was the degree awarder within a reasonable time frame after end of studies? Was the degree awarderd during the expected months.


2. confidence_score for dates_of_attendance start_date and end_date:

        start date confidence_score = (0.375 * expected_month_start) + (0.375 * duration_matches_degree_type)

        end date confidence_score = (0.375 * expected_month_end) + (0.375 * duration_matches_degree_type)

        Where
        1. expected_month_start = 1, if start month = August, September, January or February for Bachelors
           expected_month_start = 1, if start month = August, September, January, February, May, June, July for Masters, Associates, PhD
           expected_month_start = 0, otherwise


        2. expected_month_end = 1, if start month = May, June, January or December for Bachelors
           expected_month_end = 1, if start month = August, September, January, February, May, June, July for Masters, Associates, PhD
           expected_month_end = 0, otherwise


        3. duration_matches_degree_type = 1, if degree_length is between 1.5 – 3 years for Associates:
           duration_matches_degree_type = 1, if degree_length is between 3 – 5 years for Bachelors
           duration_matches_degree_type = 1, if degree_length is between 1 – 3 years for Masters
           duration_matches_degree_type = 1, if degree_length is between 3 – 8 years for PhD
           duration_matches_degree_type = 1, if degree_length is between 3-5 years for other doctorates (JD, MD PharmD etc)
           duration_matches_degree_type = 0, otherwise


        Was the degree awarder within a reasonable time frame for each degree?
        Did the degree start and end during the expected months at the beginning of fall, spring and summer semesters?


Assumptions:
    - Max value for confidence_score = 0.75, since we operate with so few values, we choose lower max confidence_score
    - PHD graduation month is also considered similar to other doctorates


Issues with this approach – if people obtain a degree while working, length of degree is going to be more than what is written here.
Future work - see if any degrees listed overlap and decrese the score if they do (out of scope for now)

Dependencies:
    - Python version: [e.g., Python 3.8]
    - Libraries:
        subprocess
        sys
        getpass
        os
        collections
        import json
        datetime import datetime
        openai
"""


#from language_agent_tree_search import tree_search_answer
import json
from datetime import datetime
import openai
import json
openai.api_key = "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"


"""## Data Extraction from json and GPT assisted processing"""

def extract_degree_info(data):
    extracted_degree_info = {}

    education_entries = data.get("person_of_interest", {}).get("education", [])
    for i, entry in enumerate(education_entries):
        # Get values and comparison results
        title_val = entry.get("degree_title", {}).get("extracted_value", None)

        start_val = entry.get("dates_of_attendance", {}).get("start_date", {}).get("extracted_value", None)
        start_cmp = entry.get("dates_of_attendance", {}).get("start_date", {}).get("comparison_result", "")

        end_val = entry.get("dates_of_attendance", {}).get("end_date", {}).get("extracted_value", None)
        end_cmp = entry.get("dates_of_attendance", {}).get("end_date", {}).get("comparison_result", "")

        award_val = entry.get("date_of_degree_awarded", {}).get("extracted_value", None)
        award_cmp = entry.get("date_of_degree_awarded", {}).get("comparison_result", "")


        # Skip if all comparison results are "MATCH"
        if all(any([cmp == "MATCH", cmp == "MATCH_NA"]) for cmp in [start_cmp, end_cmp, award_cmp]):
            continue

        # Extract school name
        school_name = entry.get("school_name", {}).get("extracted_value", None)

        degree_info = {
            "institution": school_name,
            "degree_title": title_val,
            "start_date": start_val,
            "end_date": end_val,
            "date_of_degree_awarded": award_val
        }

        extracted_degree_info[i] = degree_info

    return extracted_degree_info

#Chat GPT is used to classify the degrees and clean up the date formats

directions_prompt = 'Your task is to look at json and convert Bachelors of Science, B.S., BA etc. degrees into "Bachelors"; MS, M.E. MBA etc into "Masters"; JD, PharmD, MD etc into "Other_Doctorates"; Doctor of Philosophy PhD into "PhD". Then convert all dates into consistent %Y-%m format. If only year is present, then use %Y format. Drop the day. Return a json format without like triple backticks and \n for line breaks'

def get_chat_response(json_prompt, directions_prompt = directions_prompt):
    response = openai.chat.completions.create(
        model="gpt-4o",
        messages=[
            {"role": "system", "content": directions_prompt},
            {"role": "user", "content": json.dumps(json_prompt)}
        ],
        temperature=0.0
    )
    return json.loads(response.choices[0].message.content)



# Compute the length of each degree (end_date - start_date)

def compute_length_years(start, end):
        try:
          start_date = datetime.strptime(start, "%Y-%m")
          end_date = datetime.strptime(end, "%Y-%m")
          months = (end_date.year - start_date.year) * 12 + (end_date.month - start_date.month)
          #print(months)
        except Exception as e:
          start_date = datetime.strptime(start, "%Y")
          end_date = datetime.strptime(end, "%Y")
          months = (end_date.year - start_date.year) * 12
          #print(months)

        return round(months / 12, 1)


def add_degree_lengths(degrees_dict):
    try:
      updated_degrees = {}
      for key, degree in degrees_dict.items():
          if degree['start_date'] == '':
            degree['degree_length'] = 0
            updated_degrees[key] = degree

          elif degree['end_date'] == '':
            degree['degree_length'] = 0
            updated_degrees[key] = degree

          else:
            degree_length = compute_length_years(degree['start_date'], degree['end_date'])
            degree['degree_length'] = degree_length
            updated_degrees[key] = degree
    except Exception as e:
      degree['degree_length'] = 0
      updated_degrees[key] = degree



    return updated_degrees


# Was degree awarded within a reasonable span after the end date of education (here it is 6 months)

def get_award_date_within_months_of_end_date(degree_dict):
    award_date_within_months_of_end_date = []
    for degree in degree_dict.values():
        try:
            end = datetime.strptime(degree['end_date'], '%Y-%m')
            award = datetime.strptime(degree['date_of_degree_awarded'], '%Y-%m')
            diff_months = (award.year - end.year) * 12 + (award.month - end.month)
            award_date_within_months_of_end_date.append(1 if 0 <= diff_months <= 6 else 0)
        except:
            award_date_within_months_of_end_date.append(0)  # fallback to 0 if parsing fails
    return award_date_within_months_of_end_date


# Was the degree awarded during the exprected months of the year.
# This differs based on the tyoe of degree


def check_award_month_by_degree_type(degree_dict):
    award_month_expected_months = []

    undergrad_and_masters_months = {"05", "06", "12", "01", "02"}
    doctoral_months = {"05", "06", "08", "12", "01", "02"}

    for degree in degree_dict.values():
        try:
            award_date = degree['date_of_degree_awarded']
            award_month = datetime.strptime(award_date, "%Y-%m").strftime("%m")
            title = degree.get("degree_title", "").lower()

            if any(t in title for t in ["bachelor", "master", "associate"]):
                award_month_expected_months.append(1 if award_month in undergrad_and_masters_months else 0)
            elif any(t in title for t in ["phd", "doctor"]):
                award_month_expected_months.append(1 if award_month in doctoral_months else 0)
            else:
                award_month_expected_months.append(0)
        except Exception as e:
            #print(f"Error parsing: {degree.get('date_of_degree_awarded')} → {e}")
            award_month_expected_months.append(0)
    return award_month_expected_months


#Function calculates confidence_score and components for degree_awarded and then appends them to the json

def get_score_for_degree_awarded(certification,flags_award_month_expected_months,flag_get_award_date_within_months_of_end_date,json_prompt):

  for ind, val in enumerate(flags_award_month_expected_months):

    ind_of_institution = list(json_prompt.keys())[ind]

    cmp = certification['person_of_interest']['education'][ind_of_institution]['date_of_degree_awarded']['comparison_result']

    #check that the field is 'MATCH_TBD'
    if any([cmp == "MATCH", cmp == "MATCH_NA", cmp =='NO_MATCH']):
      continue

    #Calc the values and append them to the json
    certification['person_of_interest']['education'][ind_of_institution]['date_of_degree_awarded']['confidence_score']= ((flags_award_month_expected_months[ind])*0.375 + (flag_get_award_date_within_months_of_end_date[ind]*0.375))
    certification['person_of_interest']['education'][ind_of_institution]['date_of_degree_awarded']['award_month_expected_months']= (flags_award_month_expected_months[ind])*0.375
    certification['person_of_interest']['education'][ind_of_institution]['date_of_degree_awarded']['award_date_within_months_of_end_date']= (flag_get_award_date_within_months_of_end_date[ind]*0.375)

  return certification


# Is the start date month consistent with typical months when semester start?

def check_start_date(degree_dict):
    award_month_expected_months = []

    undergrad_and_masters_months = {"08", "09", "01", "02"} #months
    doctoral_months = {"08", "09", "01", "02", "05", "06", "07"} #months

    for degree in degree_dict.values():
        #print(degree)
        try:
            award_date = degree['start_date']
            award_month = datetime.strptime(award_date, "%Y-%m").strftime("%m")


            title = degree.get("degree_title", "").lower()

            if any(t in title for t in ["bachelor", "master", "associate"]):
                award_month_expected_months.append(1 if award_month in undergrad_and_masters_months else 0)
            elif any(t in title for t in ["phd", "doctor"]):
                award_month_expected_months.append(1 if award_month in doctoral_months else 0)
            else:
                award_month_expected_months.append(0)
        except Exception as e:
            #print(f"Error parsing: {degree.get('start_date')} → {e}")
            award_month_expected_months.append(0)
    return award_month_expected_months


# Is the end date month consistent with typical months when semester ends?

def check_end_date(degree_dict):

    award_month_expected_months = []

    undergrad_and_masters_months = {"05", "06", "01", "12"} # months
    doctoral_months = {"08", "09", "01", "02", "05", "06", "07"} # months

    for degree in degree_dict.values():

        try:
            award_date = degree['end_date']
            award_month = datetime.strptime(award_date, "%Y-%m").strftime("%m")

            title = degree.get("degree_title", "").lower()

            if any(t in title for t in ["bachelor", "master", "associate"]):
                award_month_expected_months.append(1 if award_month in undergrad_and_masters_months else 0)
            elif any(t in title for t in ["phd", "doctor"]):
                award_month_expected_months.append(1 if award_month in doctoral_months else 0)
            else:
                award_month_expected_months.append(0)
        except Exception as e:
            #print(f"Error parsing: {degree.get('start_date')} → {e}")
            award_month_expected_months.append(0)
    return award_month_expected_months



# Check if the length of the degree correcponds to average length of the degree for a given degree

def classify_degree_length(output):
    degree_ranges = {
        "associates": (1.5, 3),
        "bachelors": (3, 5),
        "masters": (1, 3),
        "phd": (3, 8),
        "other doctorates": (3, 5)  # JD, MD, PharmD
    }

    results = []

    for degree_info in output.values():
        title = (degree_info.get("degree_title") or "").lower()
        length = degree_info.get("degree_length", 0)

        # Determine category based on title keywords
        if "associate" in title:
            expected_range = degree_ranges["associates"]
        elif "bachelor" in title:
            expected_range = degree_ranges["bachelors"]
        elif "master" in title:
            expected_range = degree_ranges["masters"]
        elif "phd" in title:
            expected_range = degree_ranges["phd"]
        elif any(x in title for x in ["jd", "md", "pharmd", "doctor"]):
            expected_range = degree_ranges["other doctorates"]
        else:
            # Unknown degree type → automatically assign 0
            results.append(0)
            continue

        # Compare length to range
        if expected_range[0] <= length <= expected_range[1]:
            results.append(1)
        else:
            results.append(0)

    return results


# Function calculates confidence_score and its components for start_date and end_date and then appends them to the json

def get_score_for_start_end_date(certification,flags_end_date,flags_start_date,flags_degree_length,json_prompt):

  for ind, val in enumerate(flags_end_date):
    ind_of_institution = list(json_prompt.keys())[ind]

    # start date
    cmp = certification['person_of_interest']['education'][ind_of_institution]['dates_of_attendance']['start_date']['comparison_result']

    if any([cmp == "MATCH", cmp == "MATCH_NA", cmp =='NO_MATCH']):
      continue

    certification['person_of_interest']['education'][ind_of_institution]['dates_of_attendance']['start_date']['confidence_score']= ((flags_start_date[ind])*0.375 + (flags_degree_length[ind]*0.375))
    certification['person_of_interest']['education'][ind_of_institution]['dates_of_attendance']['start_date']['expected_month_start']= (flags_start_date[ind])*0.375
    certification['person_of_interest']['education'][ind_of_institution]['dates_of_attendance']['start_date']['duration_matches_degree_type']= (flags_degree_length[ind]*0.375)

    # end date
    cmp = certification['person_of_interest']['education'][ind_of_institution]['dates_of_attendance']['end_date']['comparison_result']
    if any([cmp == "MATCH", cmp == "MATCH_NA",cmp =='NO_MATCH']):
      continue

    certification['person_of_interest']['education'][ind_of_institution]['dates_of_attendance']['end_date']['confidence_score']= ((flags_end_date[ind])*0.375 + (flags_degree_length[ind]*0.375))
    certification['person_of_interest']['education'][ind_of_institution]['dates_of_attendance']['end_date']['expected_month_end']= (flags_end_date[ind])*0.375
    certification['person_of_interest']['education'][ind_of_institution]['dates_of_attendance']['end_date']['duration_matches_degree_type']= (flags_degree_length[ind]*0.375)

  return certification


"""## Final function that brings everything together, takes in json and returns updated json"""

def get_date_confidence_tbd_score(certification):
  '''
  Input: json education file,
  Output: json education file with additional 'confidence_score' field for 'start_date', 'end_date' and 'date_of_degree_awarded', if these were MATCH_TBD
  Components used to compute 'confidence_score' are also included in the json output following the 'confidence_score'.

  If none of the dates are MATCH_TBD, returns the same json.
  If date is an empty string, does not return a confidense score, needs more work.

  '''
  json_prompt = extract_degree_info(certification)
  output = (get_chat_response(json_prompt))
  output = add_degree_lengths(output)
  flag_get_award_date_within_months_of_end_date = get_award_date_within_months_of_end_date(output)
  flags_award_month_expected_months = check_award_month_by_degree_type(output)
  flags_start_date = check_start_date(output)
  flags_end_date = check_end_date(output)
  flags_degree_length = classify_degree_length(output)


  get_score_for_degree_awarded(certification,flags_award_month_expected_months,flag_get_award_date_within_months_of_end_date,json_prompt)
  get_score_for_start_end_date(certification,flags_end_date,flags_start_date,flags_degree_length,json_prompt)
  
  return certification


if __name__ == "__main__":
    # Example minimal test
    sample_json = {
        "person_of_interest": {
            "education": [
                {
                    "school_name": {"extracted_value": "Test University"},
                    "degree_title": {"extracted_value": "Bachelor of Science"},
                    "dates_of_attendance": {
                        "start_date": {"extracted_value": "2015-09", "comparison_result": "MATCH_TBD"},
                        "end_date": {"extracted_value": "2019-06", "comparison_result": "MATCH_TBD"}
                    },
                    "date_of_degree_awarded": {"extracted_value": "2019-06", "comparison_result": "MATCH_TBD"}
                }
            ]
        }
    }
    result = get_date_confidence_tbd_score(sample_json)
    print(result)

